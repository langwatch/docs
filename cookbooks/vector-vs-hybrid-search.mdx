---
title: Vector Search vs Hybrid Search using LanceDB
sidebarTitle: Vector Search vs Hybrid Search
description: Learn the key differences between vector search and hybrid search in RAG applications. Use cases, performance tradeoffs, and when to choose each.
keywords: [vector search, hybrid search, semantic search, lexical search, information retrieval, AI search]
---

In this cookbook, we demonstrate how to enhance retrieval performance by implementing hybrid search in your RAG applications. We'll explore how structured metadata can dramatically improve search relevance and precision beyond what vector similarity alone can achieve.

When users search for products, documents, or other content, they often have specific attributes in mind. For example, a shopper might want "red dresses for summer occasions" or a researcher might need "papers on climate change published after 2020." Pure semantic search might miss these nuances, but metadata filtering allows you to combine the power of vector search with explicit attribute filtering.

Like always, we'll focus on data-driven approaches to measure and improve retrieval performance.

## Requirements

Before starting, ensure you have the following packages installed:

```bash
pip install lancedb datasets openai tqdm pandas pyarrow tantivy pylance
```

## Setup

Start by setting up the environment:

```python
import getpass
import lancedb
import openai
from datasets import load_dataset

openai.api_key = getpass.getpass('Enter your OpenAI API key: ')
# Set up LanceDB
db = lancedb.connect('./lancedb_ecommerce_demo')
```

## The Dataset

In this cookbook, we'll work with a product catalog dataset containing fashion items with structured metadata. The dataset includes:

- **Basic product information**: titles, descriptions, brands, and prices
- **Categorization**: categories, subcategories, and product types
- **Attributes**: structured characteristics like sleeve length, neckline, and fit
- **Materials and patterns**: fabric types and design patterns

Here's what our taxonomy structure looks like:

```json
{
  "taxonomy_map": {
    "Women": {
      "Tops": {
        "product_type": [
          "T-Shirts",
          "Blouses",
          "Sweaters",
          "Cardigans",
          "Tank Tops",
          "Hoodies",
          "Sweatshirts"
        ],
        "attributes": {
          "Sleeve Length": [
            "Sleeveless",
            "Short Sleeve",
            "3/4 Sleeve",
            "Long Sleeve"
          ],
          "Neckline": [
            "Crew Neck",
            "V-Neck",
            "Turtleneck",
            "Scoop Neck",
            "Cowl Neck"
          ],
          "Fit": ["Regular", "Slim", "Oversized", "Cropped"]
        }
      },
      "Bottoms": {
        "product_type": ["Pants", "Jeans", "Shorts", "Skirts", "Leggings"],
        "attributes": {
          // Additional attributes...
        }
      }
    }
  }
}
```

Having well-structured metadata enables more precise filtering and can significantly improve search relevance, especially for domain-specific applications where users have particular attributes in mind. This data might come from manual tagging by product managers or automated processes with LLMs.

Let's first load the dataset from Huggingface:

```python
from datasets import load_dataset

labelled_dataset = load_dataset("ivanleomk/labelled-ecommerce-taxonomy")["train"]
```

## Prepare DataFrame for LanceDB

We'll use a Pandas DataFrame as the ingest interface.

```python
import pandas as pd

df = pd.DataFrame(labelled_dataset)
df["id"] = df["id"].astype(str)
```
For simplicity, use `description` as the "text" field, although you could concatenate title/description/etc.

---

## Generate Embeddings (OpenAI)

```python
import numpy as np
from tqdm import tqdm

def batch_embed(texts, model="text-embedding-3-large"):
    batch_size = 100
    embeddings = []
    for i in tqdm(range(0, len(texts), batch_size), desc="Embedding..."):
        batch = texts[i:i+batch_size]
        response = openai.embeddings.create(model=model, input=batch)
        emb = [np.array(e.embedding, dtype='float32') for e in response.data]
        embeddings.extend(emb)
    return embeddings

df["embedding"] = batch_embed(df["description"].tolist())
```

## Combine all text fields into a single searchable text field

```python
df["searchable_text"] = df.apply(
    lambda row: " ".join([
        row["title"],
        row["description"],
        row["brand"],
        row["category"],
        row["subcategory"],
        row["product_type"],
        row["attributes"],
        row["material"],
        row["pattern"],
        row["occasions"],
    ]),
    axis=1
)
df["searchable_text"].head()
```

## Ingest Data into LanceDB

```python
import pyarrow as pa

table_schema = pa.schema(
    [
        pa.field("id", pa.string()),
        pa.field("description", pa.string()),
        pa.field("title", pa.string()),
        pa.field("brand", pa.string()),
        pa.field("category", pa.string()),
        pa.field("subcategory", pa.string()),
        pa.field("product_type", pa.string()),
        pa.field("attributes", pa.string()),
        pa.field("material", pa.string()),
        pa.field("pattern", pa.string()),
        pa.field("price", pa.float64()),
        pa.field("occasions", pa.string()),
        pa.field(
            "embedding", pa.list_(pa.float32(), 3072)
        ),  # size depends on your model!!
        pa.field("searchable_text", pa.string()),
    ]
)

# Drop unused columns
df_ = df.drop(columns=["image"])

# Create table + upload data
if "products" in db.table_names():
    tbl = db.open_table("products")
else:
    tbl = db.create_table("products", data=df_, schema=table_schema, mode="overwrite")

tbl.create_fts_index("searchable_text", replace=True)
```

## Understanding Our Vector Database

We've now loaded our product catalog into a LanceDB vector database along with multiple text fields.

This setup allows us to perform both:

- **Pure semantic search**: Finding products based on the meaning of their descriptions
- **Hybrid search**: Combining semantic similarity with explicit metadata filters

The embeddings are generated using OpenAI's embedding model, which creates high-dimensional vectors that represent the semantic content of each product description. Similar products will have vectors that are close together in this high-dimensional space.

## Generating Synthetic Data

When you don't have production data to start with, you can generate synthetic data to simulate a real-world scenario. We already have the 'output', which is the clothing item we just embedded. We now want to generate synthetic queries that would be relevant to the clothing item.

In this case, we'll use GPT-4o-mini to generate realistic user queries that would naturally lead to each product in our catalog. This gives us query-product pairs where we know the ground truth relevance.

```python
import random
from openai import OpenAI
from tqdm import tqdm

# Initialize OpenAI client
client = OpenAI(api_key=openai.api_key)

# Define query types to generate variety
query_types = [
    "Basic search for specific item",
    "Search with price constraint",
    "Search for specific occasion",
    "Search with material preference",
    "Search with style/attribute preference"
]

def generate_synthetic_query(item):
    """Generate a realistic search query for a clothing item"""

    # Select a random query type
    query_type = random.choice(query_types)

    # Create prompt for the LLM
    prompt = f"""
    Generate a realistic search query that would lead someone to find this specific clothing item:

    Item Details:
    - Title: {item["title"]}
    - Description: {item["description"]}
    - Category: {item["category"]}
    - Subcategory: {item["subcategory"]}
    - Product Type: {item["product_type"]}
    - Price: ${item["price"]}
    - Material: {item["material"]}
    - Attributes: {item["attributes"]}
    - Occasions: {item["occasions"]}

    The query should be in a conversational tone, about 10-20 words, and focus on a {query_type.lower()}.
    Don't mention the exact product name, but include specific details that would make this item a perfect match.

    Example: For a $120 silk blouse with long sleeves, a query might be:
    "Looking for an elegant silk top with long sleeves for work, under $150"
    """

    # Generate query using OpenAI
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "You are a helpful assistant that generates realistic shopping queries."},
            {"role": "user", "content": prompt}
        ]
    )

    # Extract the generated query
    query = response.choices[0].message.content.strip().strip('"')

    return {"query": query, **item}

# Generate queries
synthetic_queries = []
for item in tqdm(labelled_dataset, desc="Generating queries"):
    query_data = generate_synthetic_query(item)
    synthetic_queries.append(query_data)
```

Let's visualize what this looks like:

```python
from rich import print

print(synthetic_queries[0])
```

```json
{
    'query': 'Searching for a sleeveless top with lace detailing at the neckline for casual outings and dinner
dates.',
    'image': <PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=768x1024 at 0x13E0BB230>,
    'title': 'Lace Detail Sleeveless Top',
    'brand': 'H&M',
    'description': "Elevate your casual wardrobe with this elegant sleeveless top featuring intricate lace
detailing at the neckline. Perfect for both day and night, it's crafted from a soft, breathable fabric for all-day
comfort.",
    'category': 'Women',
    'subcategory': 'Tops',
    'product_type': 'Tank Tops',
    'attributes': '[{"name": "Sleeve Length", "value": "Sleeveless"}, {"name": "Neckline", "value": "Crew Neck"}]',
    'material': 'Cotton',
    'pattern': 'Solid',
    'id': 1,
    'price': 181.04,
    'occasions': '["Everyday Wear", "Casual Outings", "Smart Casual", "Dinner Dates", "Partywear"]'
}
```

### **Hybrid Search in LanceDB**

**LanceDB syntax for hybrid search:**

```python
text_query = "dress for wedding guests"
vector_query = openai.embeddings.create(model="text-embedding-3-large", input=text_query).data[0].embedding

results = tbl.search(query_type="hybrid") \
    .text(text_query) \
    .vector(vector_query) \
    .limit(5) \
    .to_pandas()
```

- **hybrid** method: blends semantic (`embedding`) and lexical (BM25) scores.
- BM25 is over the table's indexed string column (which by default is the whole searchable_text column).

---

## **Retrieval & Evaluation Functions**

Here's retrieval for **three modes**:
- **Pure semantic (vector)**
- **Pure lexical (keyword)**
- **Hybrid (weighted blend)**

```python
import re

def sanitize_query(query):
    # Remove characters that break LanceDB FTS queries
    return re.sub(r"['\"\\]", "", query)

def search_semantic(tbl, query, embedding, k=5):
    return tbl.search(embedding).limit(k).to_pandas()["id"].tolist()

def search_lexical(tbl, query, k=5):
    # BM25 over description field
    return tbl.search(query=sanitize_query(query), query_type="fts").limit(k).to_pandas()["id"].tolist()

def search_hybrid(tbl, query, embedding, k=5):
    # Blends vector and BM25
    return tbl.search(query_type="hybrid").text(sanitize_query(query)).vector(embedding).limit(k).to_pandas()["id"].tolist()
```

## Retrieval Evaluation: Semantic Search vs. Metadata Filtering

Now comes the critical part - evaluating how well each retrieval method performs. We'll compare pure semantic search against hybrid search using two key metrics:

1. **Recall**: The proportion of relevant items successfully retrieved
2. **Mean Reciprocal Rank (MRR)**: How high relevant items appear in our results

These metrics help us understand different aspects of retrieval quality:

- High recall means we're finding most of the relevant items
- High MRR means we're ranking relevant items near the top of the results

By comparing these metrics across different retrieval methods, we can make data-driven decisions about which approach works best for our specific use case.

```python
def recall(retrieved, expected):
    return float(len(set(retrieved).intersection(set(expected)))) / len(expected)

def mrr(retrieved, expected):
    # expected: list of relevant document ids (strings)
    for rank, doc_id in enumerate(retrieved, 1):
        if doc_id in expected:
            return 1.0 / rank
    return 0.0

def evaluate_search(tbl, queries, expected_ids, embeddings, k=5):
    metrics = dict(semantic=[], lexical=[], hybrid=[])
    for idx, query in enumerate(tqdm(queries, desc="Evaluating...")):
        eid = expected_ids[idx]
        emb = embeddings[idx]
        metrics["semantic"].append({
            "recall": recall(search_semantic(tbl, query, emb, k), eid),
            "mrr": mrr(search_semantic(tbl, query, emb, k), eid)
        })
        metrics["lexical"].append({
            "recall": recall(search_lexical(tbl, query, k), eid),
            "mrr": mrr(search_lexical(tbl, query, k), eid)
        })
        metrics["hybrid"].append({
            "recall": recall(search_hybrid(tbl, query, emb, k, weight=0.5), eid),
            "mrr": mrr(search_hybrid(tbl, query, emb, k, weight=0.5), eid)
        })
    return metrics
```

For this evaluation, we'll compare two distinct retrieval approaches:

- **Pure Semantic Search**: Using only vector embeddings to find similar items
- **Hybrid Search**: Combining vector similarity with BM25 search

This comparison will demonstrate how metadata filtering can significantly improve retrieval precision and relevance, especially for queries with specific attributes or constraints.

## **Prepare Evaluation Data**

Assuming your **synthetic queries** are a list of dicts with `"query"` and `"id"`.

```python
queries = [item["query"] for item in synthetic_queries]
expected_ids = [[str(item["id"])] for item in synthetic_queries]
query_embeddings = batch_embed(queries)  # for fair test, encode queries w/same embedding model
```

---

## **Run the Experiment**

```python
k_values = [3, 5, 10]
results = []

for k in k_values:
    metrics = evaluate_search(tbl, queries, expected_ids, query_embeddings, k=k)
    import numpy as np
    def aggregate_metrics(metrics):
        return {m: {"recall": np.mean([x["recall"] for x in v]),
                    "mrr": np.mean([x["mrr"] for x in v])} for m, v in metrics.items()}
    summary = aggregate_metrics(metrics)
    for method, vals in summary.items():
        results.append({"k": k, "method": method, "recall": vals["recall"], "mrr": vals["mrr"]})

results_df = pd.DataFrame(results)
print(results_df)
```


## --Conclusion-- TO BE UPDATED

Whilst writing this cookbook, I had secretly 'hoped' that hybrid search would outperform pure semantic search. Most people default to vector embeddings, but in production I found that structured metadata extraction consistently delivered better results.

However, this analysis shows that no application is the same. There is no 'universal' best method for doing things - it depends on the specific use case and the data at hand. In our particular experiment:

- Pure semantic search achieved higher recall and MRR across all k values
- This suggests that for this specific dataset and query set, the semantic meaning captured by embeddings was sufficient
- The additional complexity of metadata filtering didn't provide an advantage in this case

This highlights the importance of empirical evaluation rather than assuming one approach is always superior. Some possible reasons for these results:

1. Our synthetic queries might be particularly well-aligned with the semantic content
2. The metadata extraction might need refinement to better capture query intent
3. The dataset might not have enough attribute diversity to showcase the benefits of filtering

I hope this analysis helps you make informed decisions about the best approach for your own use case.

For the full notebook, check it out on: [GitHub](https://github.com/langwatch/cookbooks/blob/main/notebooks/metadata-filtering.ipynb).
